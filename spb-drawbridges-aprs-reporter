#!/usr/bin/env python3

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import argparse
import csv
import os
import re

import aprslib
from transliterate import slugify

from objectreport import ObjectReport


def parse_time(time_str):
    if not re.match(r"[0-9]{1,2}\.[0-9]{2}", time_str):
        return None

    return time_str.replace('.', ':')


def parse_schedule_csv(csv_file):
    csv_reader = csv.DictReader(csv_file)

    schedule = []
    for row in csv_reader:
        if 'по предварительной заявке' in row['Наименование моста']:
            continue

        first_interval = (parse_time(row['Время первой разводки']), parse_time(row['Время первой сводки']))
        second_interval = (parse_time(row['Время второй разводки']), parse_time(row['Время второй сводки']))
        intervals = [first_interval] if second_interval[0] is None else [first_interval, second_interval]

        coordinates = row['Координаты'].split(',')

        schedule.append({
            'bridge_name': row['Наименование моста'],
            'intervals': intervals,
            'coordinates': {
                'latitude': float(coordinates[0]),
                'longitude': float(coordinates[1]),
            }
        })

    return schedule


def create_bridge_beacons(bridges, callsign):
    beacons = []
    for bridge in bridges:
        object_name = slugify(re.sub('мост', '', bridge['bridge_name'], flags=re.I), 'ru').title()
        comment = 'Open ' + ' and '.join([f'from {frm} to {to}' for (frm, to) in bridge['intervals']])

        beacon = ObjectReport({
            'fromcall': callsign,
            'tocall': 'APRS',
            'path': ['TCPIP*'],
            'symbol_table': '/',
            'symbol': 'Y',
            'object_name': object_name,
            'latitude': bridge['coordinates']['latitude'],
            'longitude': bridge['coordinates']['longitude'],
            'comment': comment,
        })
        beacons.append(beacon)

    return beacons


def report_beacons_to_aprs(beacons, callsign, server, port, password):
    aprs = aprslib.IS(
        callsign,
        passwd=password,
        host=server,
        port=port,
    )
    aprs.connect(blocking=True)

    for beacon in beacons:
        aprs.sendall(beacon)

    aprs.close()


if __name__ == '__main__':
    args_parser = argparse.ArgumentParser(description='Videos to images')
    args_parser.add_argument(
        '--schedule-csv',
        type=argparse.FileType('r', encoding='utf-8-sig'),
        help='drawbridges schedule CSV from https://data.gov.spb.ru/irsi/7830001853-grafik-razvodki-mostov/',
        required=True,
    )
    args_parser.add_argument('--callsign', help='callsign', required=True)
    aprsis = args_parser.add_argument_group('aprsis', 'APRS-IS settings')
    aprsis.add_argument('--aprsis-server', required=True)
    aprsis.add_argument('--aprsis-port', type=int, default=14580)
    aprsis.add_argument('--aprsis-password', default=os.environ.get('APRSIS_PASSWORD'))
    args = args_parser.parse_args()

    schedule = parse_schedule_csv(args.schedule_csv)
    bridge_beacons = create_bridge_beacons(schedule, args.callsign)
    report_beacons_to_aprs(bridge_beacons, args.callsign, args.aprsis_server, args.aprsis_port, args.aprsis_password)
